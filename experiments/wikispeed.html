<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Wikipedia Speed Run</title>
    <style>
      :root {
        --bg-color: #f4f4f0;
        --accent: #2c3e50;
        --highlight: #e74c3c;
        --text: #2f3542;
        --border: 3px solid #2f3542;
        --shadow: 4px 4px 0px #2f3542;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Courier New", Courier, monospace;
        background: var(--bg-color);
        color: var(--text);
        line-height: 1.6;
        padding-bottom: 2rem;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 1rem;
      }

      /* --- Header --- */
      header {
        text-align: center;
        margin-bottom: 2rem;
        padding: 2rem;
        background: white;
        border: var(--border);
        box-shadow: var(--shadow);
      }

      h1 {
        font-size: 2.5rem;
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: -1px;
        margin-bottom: 0.5rem;
      }

      /* --- Layout --- */
      .game-layout {
        display: grid;
        grid-template-columns: 300px 1fr;
        gap: 1.5rem;
        align-items: start;
      }

      @media (max-width: 900px) {
        .game-layout {
          grid-template-columns: 1fr;
        }
      }

      /* --- Sidebar --- */
      .sidebar {
        background: white;
        border: var(--border);
        box-shadow: var(--shadow);
        padding: 1.5rem;
        position: sticky;
        top: 1rem;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        z-index: 10;
      }

      .target-box {
        background: var(--highlight);
        color: white;
        padding: 1rem;
        border: var(--border);
        text-align: center;
      }

      .target-label {
        font-size: 0.8rem;
        text-transform: uppercase;
        font-weight: bold;
        opacity: 0.9;
      }

      .target-title {
        font-size: 1.4rem;
        font-weight: 900;
        line-height: 1.2;
        margin-top: 0.5rem;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
      }

      .stat-item {
        text-align: center;
        background: #eee;
        padding: 0.5rem;
        border: 2px solid #ddd;
      }
      .stat-val {
        font-size: 1.8rem;
        font-weight: 900;
      }
      .stat-lbl {
        font-size: 0.7rem;
        text-transform: uppercase;
        font-weight: bold;
        color: #777;
      }

      /* --- Game Board --- */
      .game-board {
        background: white;
        border: var(--border);
        box-shadow: var(--shadow);
        min-height: 80vh;
        display: flex;
        flex-direction: column;
        position: relative;
      }

      .breadcrumbs {
        padding: 1rem;
        background: #eee;
        border-bottom: var(--border);
        font-size: 0.85rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
      }

      .crumb {
        color: #666;
      }
      .crumb:last-child {
        color: var(--highlight);
        font-weight: bold;
      }
      .crumb::after {
        content: "→";
        margin-left: 0.5rem;
        color: #ccc;
      }
      .crumb:last-child::after {
        display: none;
      }

      /* --- Wiki Content Styling --- */
      .wiki-content {
        padding: 2rem;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        font-size: 1.1rem;
        overflow-x: hidden;
        position: relative;
      }

      .wiki-content.loading {
        opacity: 0.5;
        pointer-events: none;
        user-select: none;
      }

      /* Loading Overlay */
      .loader-overlay {
        position: absolute;
        inset: 0;
        background: rgba(255, 255, 255, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 50;
        backdrop-filter: blur(2px);
      }
      .loader-text {
        font-family: "Courier New", monospace;
        font-weight: 900;
        font-size: 2rem;
        color: var(--highlight);
        background: white;
        padding: 1rem 2rem;
        border: var(--border);
        box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.2);
        animation: pulse 0.8s infinite alternate;
      }
      @keyframes pulse {
        from {
          transform: scale(1);
        }
        to {
          transform: scale(1.05);
        }
      }

      /* Cleanup Wiki garbage */
      .wiki-content .mw-empty-elt,
      .wiki-content .infobox,
      .wiki-content .sidebar,
      .wiki-content .thumb,
      .wiki-content .reference,
      .wiki-content .hatnote,
      .wiki-content .ambox,
      .wiki-content .reflist,
      .wiki-content table,
      .wiki-content .mw-editsection {
        display: none !important;
      }

      .wiki-content h1 {
        font-size: 2.2rem;
        margin-bottom: 1rem;
        border-bottom: 2px solid #eee;
        padding-bottom: 0.5rem;
      }
      .wiki-content h2 {
        font-size: 1.8rem;
        margin-top: 2rem;
        margin-bottom: 1rem;
        border-bottom: 1px solid #eee;
      }
      .wiki-content p {
        margin-bottom: 1rem;
        line-height: 1.6;
      }
      .wiki-content ul {
        padding-left: 2rem;
        margin-bottom: 1rem;
      }

      /* Links */
      .wiki-content a {
        color: #2980b9;
        text-decoration: none;
        font-weight: 500;
        cursor: pointer;
        padding: 0 2px;
        border-radius: 2px;
        transition: background 0.1s;
      }
      .wiki-content a:hover {
        text-decoration: underline;
        background: #e8f4fc;
        color: #1a5276;
      }
      /* Dead links */
      .wiki-content a.disabled-link {
        color: #bbb;
        pointer-events: none;
        cursor: default;
        text-decoration: none;
      }

      /* --- Buttons --- */
      button {
        background: var(--text);
        color: white;
        border: none;
        padding: 1rem 2rem;
        font-family: inherit;
        font-weight: 900;
        font-size: 1rem;
        cursor: pointer;
        border: 3px solid transparent;
        transition: all 0.2s;
        text-transform: uppercase;
      }
      button:hover {
        background: white;
        color: var(--text);
        border: var(--border);
        transform: translate(-2px, -2px);
        box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.2);
      }
      button.secondary {
        background: #ddd;
        color: var(--text);
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      /* --- Leaderboard --- */
      .leaderboard-section {
        margin-top: 2rem;
        border-top: 2px solid #eee;
        padding-top: 2rem;
      }
      .lb-tabs {
        display: flex;
        gap: 0.5rem;
        justify-content: center;
        margin-bottom: 1rem;
      }
      .lb-tab {
        padding: 0.5rem 1rem;
        background: #eee;
        border: 2px solid #ddd;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.2s;
      }
      .lb-tab.active {
        background: var(--highlight);
        color: white;
        border-color: var(--highlight);
      }
      .lb-row {
        display: flex;
        justify-content: space-between;
        padding: 0.8rem;
        border-bottom: 1px solid #eee;
        font-family: -apple-system, sans-serif;
        font-size: 0.95rem;
      }
      .lb-row:nth-child(odd) {
        background: #fafafa;
      }
      .lb-rank {
        font-weight: bold;
        width: 30px;
        color: #888;
      }
      .lb-name {
        font-weight: 600;
        flex-grow: 1;
        text-align: left;
      }
      .lb-stat {
        font-family: "Courier New", monospace;
        color: var(--text);
      }

      /* --- Modal --- */
      .modal-overlay {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        align-items: center;
        justify-content: center;
      }
      .modal {
        background: white;
        padding: 3rem;
        max-width: 600px;
        width: 90%;
        border: var(--border);
        box-shadow: 10px 10px 0px rgba(255, 255, 255, 0.2);
        text-align: center;
      }
      .hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header id="menuScreen">
        <h1>Wiki Speed Run</h1>
        <p style="margin-bottom: 2rem; color: #666">
          Navigate from A to B using only internal links. <br />
          <small>Timer pauses while pages load.</small>
        </p>

        <div class="controls">
          <button id="startBtn">Start Game</button>
        </div>

        <div class="leaderboard-section">
          <h3>Your Personal Bests (Local)</h3>
          <div
            id="localStats"
            style="
              margin-top: 1rem;
              font-style: italic;
              color: #888;
              font-size: 0.9rem;
            "
          >
            No games played yet.
          </div>
        </div>

        <div class="leaderboard-section">
          <h3>Global Leaderboard</h3>
          <div class="lb-tabs">
            <div class="lb-tab active" data-sort="clicks">By Clicks</div>
            <div class="lb-tab" data-sort="time">By Time</div>
          </div>
          <div
            id="leaderboardList"
            style="margin-top: 1rem; max-height: 400px; overflow-y: auto"
          >
            Loading...
          </div>
        </div>
      </header>

      <div id="gameScreen" class="game-layout hidden">
        <aside class="sidebar">
          <div class="target-box">
            <div class="target-label">Target Page</div>
            <div class="target-title" id="targetDisplay">?</div>
            <div class="target-desc" id="targetDesc">...</div>
          </div>

          <div class="stats-grid">
            <div class="stat-item">
              <div class="stat-val" id="clickCount">0</div>
              <div class="stat-lbl">Clicks</div>
            </div>
            <div class="stat-item">
              <div class="stat-val" id="timerDisplay">0:00</div>
              <div class="stat-lbl">Time</div>
            </div>
          </div>

          <button class="secondary" id="giveUpBtn">Give Up</button>
        </aside>

        <main class="game-board">
          <div class="breadcrumbs" id="breadcrumbs"></div>
          <div id="wikiLoader" class="loader-overlay hidden">
            <div class="loader-text">TRAVELING...</div>
          </div>
          <div class="wiki-content" id="wikiContent"></div>
        </main>
      </div>
    </div>

    <div class="modal-overlay" id="winModal">
      <div class="modal">
        <h2
          style="color: var(--highlight); font-size: 3rem; margin-bottom: 1rem"
        >
          VICTORY!
        </h2>
        <p>
          You reached <strong><span id="winTargetName"></span></strong>
        </p>

        <div class="stats-grid" style="margin: 2rem 0">
          <div class="stat-item">
            <div class="stat-val" id="winClicks">0</div>
            <div class="stat-lbl">Clicks</div>
          </div>
          <div class="stat-item">
            <div class="stat-val" id="winTime">0:00</div>
            <div class="stat-lbl">Time</div>
          </div>
        </div>

        <input
          type="text"
          id="playerName"
          placeholder="Enter Name for Leaderboard"
          style="
            padding: 1rem;
            border: var(--border);
            width: 100%;
            margin-bottom: 1rem;
            font-size: 1.1rem;
            text-align: center;
          "
        />
        <button id="submitScoreBtn">Submit Score</button>
        <button class="secondary" id="playAgainBtn" style="margin-top: 0.5rem">
          Play Again
        </button>
      </div>
    </div>

    <script>
      // --- CONFIG ---
      const APPS_SCRIPT_URL =
        "https://script.google.com/macros/s/AKfycbxJLd1l2RWakcrO0Txnjo65Cp4Bqp2RKe84R7bAwESuTvDTeDrMxF4mNXveKBUc108G/exec";

      // --- DATA LISTS ---
      const startingPoints = [
        "Vuvuzela",
        "Kazoo",
        "Didgeridoo",
        "Theremin",
        "Hurdy-gurdy",
        "Ocarina",
        "Pennywhistle",
        "Concertina",
        "Melodica",
        "Mbira",
        "Quokka",
        "Axolotl",
        "Pangolin",
        "Okapi",
        "Narwhal",
        "Tapir",
        "Dugong",
        "Capybara",
        "Numbat",
        "Cassowary",
        "Samosa",
        "Pierogi",
        "Empanada",
        "Beignet",
        "Churro",
        "Baklava",
        "Dim_sum",
        "Mochi",
        "Stroopwafel",
        "Cannoli",
        "Zoetrope",
        "Astrolabe",
        "Sextant",
        "Orrery",
        "Pantograph",
        "Planisphere",
        "Chronometer",
        "Theodolite",
        "Anemometer",
        "Hygrometer",
        "Zorbing",
        "Parkour",
        "Slacklining",
        "Bouldering",
        "Geocaching",
        "Sandboarding",
        "Kitesurfing",
        "Orienteering",
        "Canyoning",
        "Spelunking",
        "Sitar",
        "Koto",
        "Balalaika",
        "Mandolin",
        "Dulcimer",
        "Bouzouki",
        "Shamisen",
        "Erhu",
        "Gamelan",
        "Origami",
        "Macramé",
        "Decoupage",
        "Pyrography",
        "Marquetry",
        "Scrimshaw",
        "Batik",
        "Cloisonné",
        "Niello",
        "Intarsia",
        "Capoeira",
        "Kabuki",
        "Kathakali",
        "Butoh",
        "Taiko",
        "Flamenco",
        "Sumo",
        "Kabaddi",
        "Sepak_takraw",
        "Petanque",
      ];
      const targetTopics = [
        "Heisenberg_uncertainty_principle",
        "Schrödinger's_cat",
        "Fermi_paradox",
        "Gödel's_incompleteness_theorems",
        "P_versus_NP_problem",
        "Riemann_hypothesis",
        "Navier–Stokes_existence_and_smoothness",
        "Twin_prime_conjecture",
        "Collatz_conjecture",
        "Goldbach's_conjecture",
        "Traveling_salesman_problem",
        "Banach–Tarski_paradox",
        "Arrow's_impossibility_theorem",
        "Prisoner's_dilemma",
        "Ship_of_Theseus",
        "Chinese_room",
        "Mary's_room",
        "Trolley_problem",
        "Omnipotence_paradox",
        "Zeno's_paradoxes",
        "Sorites_paradox",
        "Russell's_paradox",
        "Barber_paradox",
        "Liar_paradox",
        "Theseus's_paradox",
        "Grandfather_paradox",
        "Bootstrap_paradox",
        "Monty_Hall_problem",
        "Birthday_problem",
        "Sleeping_Beauty_problem",
        "Two_envelopes_problem",
        "Unexpected_hanging_paradox",
        "Hilbert's_paradox_of_the_Grand_Hotel",
        "Gabriel's_Horn",
        "Koch_snowflake",
        "Menger_sponge",
        "Sierpiński_triangle",
        "Barnsley_fern",
        "Mandelbrot_set",
        "Julia_set",
        "Lorenz_attractor",
        "Halting_problem",
        "Byzantine_fault",
        "CAP_theorem",
        "Turing_completeness",
        "Lambda_calculus",
        "Church–Turing_thesis",
        "NP-completeness",
        "Chomsky_hierarchy",
        "Rice's_theorem",
        "Curry–Howard_correspondence",
        "Y_combinator",
        "Qualia",
        "Philosophical_zombie",
        "Hard_problem_of_consciousness",
        "Cartesian_doubt",
        "Cogito,_ergo_sum",
        "Kantian_ethics",
        "Categorical_imperative",
        "Veil_of_ignorance",
        "Original_position",
        "Übermensch",
        "Eternal_return",
        "Will_to_power",
        "Dasein",
        "Being_and_Time",
        "Phenomenology",
        "Tabula_rasa",
        "Social_contract",
        "State_of_nature",
        "Panpsychism",
        "Neutral_monism",
        "Eliminative_materialism",
        "Mereological_nihilism",
        "Four-dimensionalism",
        "Endurantism",
      ];

      // --- STATE MANAGEMENT ---
      let gameState = {
        active: false,
        isLoading: false,
        startPage: "",
        targetPage: "",
        currentPage: "",
        clicks: 0,
        startTime: 0,
        totalPausedTime: 0,
        pauseStart: 0,
        path: [],
        timerInterval: null,
      };

      // Cache leaderboard to fix "smoothness" issue
      let globalScoresCache = [];
      let currentLeaderboardSort = "clicks";

      // --- DOM ELEMENTS ---
      const els = {
        menu: document.getElementById("menuScreen"),
        game: document.getElementById("gameScreen"),
        content: document.getElementById("wikiContent"),
        loader: document.getElementById("wikiLoader"),
        breadcrumbs: document.getElementById("breadcrumbs"),
        targetDisplay: document.getElementById("targetDisplay"),
        targetDesc: document.getElementById("targetDesc"),
        clicks: document.getElementById("clickCount"),
        timer: document.getElementById("timerDisplay"),
        winModal: document.getElementById("winModal"),
        startBtn: document.getElementById("startBtn"),
        leaderboardList: document.getElementById("leaderboardList"),
      };

      // --- UTILS ---
      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, "0")}`;
      };

      const normalizeTitle = (t) => t.replace(/_/g, " ").trim();

      // --- LEADERBOARD LOGIC ---
      async function fetchGlobalLeaderboard() {
        try {
          // Fetch once
          const res = await fetch(`${APPS_SCRIPT_URL}?action=getScores`);
          const data = await res.json();

          if (data.records) {
            globalScoresCache = data.records.filter(
              (s) =>
                s && typeof s.clicks === "number" && typeof s.time === "number"
            );
          }
          renderLeaderboard();
        } catch (e) {
          console.error("Leaderboard fetch failed", e);
          els.leaderboardList.innerHTML =
            "<small>Could not load leaderboard.</small>";
        }
      }

      function renderLeaderboard() {
        if (!globalScoresCache.length) {
          els.leaderboardList.innerHTML = "<small>No scores yet.</small>";
          return;
        }

        // Sort locally - Smooth switching
        const sorted = [...globalScoresCache].sort((a, b) => {
          if (currentLeaderboardSort === "clicks") {
            if (a.clicks !== b.clicks) return a.clicks - b.clicks;
            return a.time - b.time;
          } else {
            if (a.time !== b.time) return a.time - b.time;
            return a.clicks - b.clicks;
          }
        });

        const top10 = sorted.slice(0, 10);

        els.leaderboardList.innerHTML = top10
          .map(
            (s, i) => `
          <div class="lb-row">
            <span class="lb-rank">#${i + 1}</span>
            <span class="lb-name">${s.playerName || "Anonymous"}</span>
            <span class="lb-stat">${s.clicks} clicks • ${formatTime(
              s.time
            )}</span>
          </div>
        `
          )
          .join("");
      }

      // --- GAMEPLAY LOGIC ---
      async function startGame() {
        gameState = {
          active: true,
          isLoading: false,
          startPage:
            startingPoints[Math.floor(Math.random() * startingPoints.length)],
          targetPage:
            targetTopics[Math.floor(Math.random() * targetTopics.length)],
          currentPage: "",
          clicks: 0,
          startTime: Date.now(),
          totalPausedTime: 0,
          pauseStart: 0,
          path: [],
          timerInterval: null,
        };

        // UI Reset
        els.menu.classList.add("hidden");
        els.game.classList.remove("hidden");
        els.winModal.style.display = "none";
        els.clicks.textContent = "0";
        els.timer.textContent = "0:00";
        els.content.innerHTML = "";

        // Setup Target
        els.targetDisplay.textContent = normalizeTitle(gameState.targetPage);
        els.targetDesc.textContent = "Loading info...";

        // Start Timer Loop
        if (gameState.timerInterval) clearInterval(gameState.timerInterval);
        gameState.timerInterval = setInterval(updateTimer, 100);

        // Fetch Target Summary (background)
        fetch(
          `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(
            gameState.targetPage
          )}`
        )
          .then((r) => r.json())
          .then(
            (d) =>
              (els.targetDesc.textContent =
                d.description || d.extract || "Target Page")
          )
          .catch(() => (els.targetDesc.textContent = "Wiki Article"));

        // Load First Page
        await loadPage(gameState.startPage);
      }

      function updateTimer() {
        if (!gameState.active || gameState.isLoading) return;

        // Calculate effective time: (Now - Start) - (Total Time Spent Loading)
        const currentDiff =
          Date.now() - gameState.startTime - gameState.totalPausedTime;
        const seconds = Math.floor(currentDiff / 1000);
        els.timer.textContent = formatTime(seconds);
      }

      async function loadPage(title) {
        // PAUSE TIMER START
        gameState.isLoading = true;
        gameState.pauseStart = Date.now();
        els.loader.classList.remove("hidden");
        els.content.classList.add("loading");

        try {
          const endpoint = `https://en.wikipedia.org/w/api.php?action=parse&page=${encodeURIComponent(
            title
          )}&prop=text&format=json&origin=*&redirects=1&disabletoc=1`;

          const response = await fetch(endpoint);
          const data = await response.json();

          if (data.error) throw new Error("Page not found");

          const html = data.parse.text["*"];
          const realTitle = data.parse.title;

          // Update State
          gameState.currentPage = realTitle;
          gameState.path.push(realTitle);

          // Render
          els.content.innerHTML = html;
          updateBreadcrumbs();
          window.scrollTo(0, 0);

          // Check Win Condition
          const cleanCurrent = normalizeTitle(realTitle).toLowerCase();
          const cleanTarget = normalizeTitle(
            gameState.targetPage
          ).toLowerCase();

          if (cleanCurrent === cleanTarget) {
            handleWin();
            // Don't unpause if win
            return;
          }
        } catch (e) {
          console.error(e);
          alert("Error loading page. Try clicking again.");
        } finally {
          // PAUSE TIMER END
          if (gameState.active) {
            const pauseDuration = Date.now() - gameState.pauseStart;
            gameState.totalPausedTime += pauseDuration;

            gameState.isLoading = false;
            els.loader.classList.add("hidden");
            els.content.classList.remove("loading");
          }
        }
      }

      // High Performance Event Delegation (Fixes "smoothness" of clicks)
      els.content.addEventListener("click", (e) => {
        if (!gameState.active || gameState.isLoading) return;

        // Find closest anchor tag
        const link = e.target.closest("a");
        if (!link) return;

        e.preventDefault();

        const href = link.getAttribute("href");

        // Check if it's a valid internal wiki link
        if (href && href.startsWith("/wiki/") && !href.includes(":")) {
          const nextTitle = decodeURIComponent(href.split("/wiki/")[1]);
          gameState.clicks++;
          els.clicks.textContent = gameState.clicks;
          loadPage(nextTitle);
        }
      });

      // Disable other links
      els.content.addEventListener("mouseover", (e) => {
        const link = e.target.closest("a");
        if (link) {
          const href = link.getAttribute("href");
          if (!href || !href.startsWith("/wiki/") || href.includes(":")) {
            link.classList.add("disabled-link");
          }
        }
      });

      function updateBreadcrumbs() {
        const displayPath =
          gameState.path.length > 4
            ? ["...", ...gameState.path.slice(-4)]
            : gameState.path;

        els.breadcrumbs.innerHTML = displayPath
          .map((t) => `<span class="crumb">${normalizeTitle(t)}</span>`)
          .join("");
      }

      function handleWin() {
        gameState.active = false;
        clearInterval(gameState.timerInterval);

        // Final calculation
        const finalSeconds = Math.floor(
          (Date.now() - gameState.startTime - gameState.totalPausedTime) / 1000
        );

        document.getElementById("winTargetName").textContent = normalizeTitle(
          gameState.targetPage
        );
        document.getElementById("winClicks").textContent = gameState.clicks;
        document.getElementById("winTime").textContent =
          formatTime(finalSeconds);

        els.winModal.style.display = "flex";

        // Save local history
        saveLocalScore(gameState.clicks, finalSeconds);
      }

      // --- DATA STORAGE ---
      function saveLocalScore(clicks, time) {
        const history = JSON.parse(
          localStorage.getItem("wikiSpeedRun_history") || "[]"
        );
        history.push({
          clicks: parseInt(clicks),
          time: parseInt(time),
          route: `${gameState.startPage} -> ${gameState.targetPage}`,
          date: new Date().toLocaleDateString(),
        });
        localStorage.setItem("wikiSpeedRun_history", JSON.stringify(history));
        renderLocalStats();
      }

      function renderLocalStats() {
        const history = JSON.parse(
          localStorage.getItem("wikiSpeedRun_history") || "[]"
        );
        if (!history.length) return;

        const valid = history.filter((h) => h.clicks > 0);
        if (!valid.length) return;

        const bestClick = [...valid].sort((a, b) => a.clicks - b.clicks)[0];
        const bestTime = [...valid].sort((a, b) => a.time - b.time)[0];

        document.getElementById("localStats").innerHTML = `
          <strong>Best Clicks:</strong> ${bestClick.clicks} (${formatTime(
          bestClick.time
        )})<br>
          <strong>Best Time:</strong> ${formatTime(bestTime.time)} (${
          bestTime.clicks
        } clicks)
        `;
      }

      // --- EVENT LISTENERS ---
      els.startBtn.addEventListener("click", startGame);

      document.getElementById("giveUpBtn").addEventListener("click", () => {
        if (confirm("Give up?")) location.reload();
      });

      document
        .getElementById("playAgainBtn")
        .addEventListener("click", () => location.reload());

      document
        .getElementById("submitScoreBtn")
        .addEventListener("click", async function () {
          const name = document.getElementById("playerName").value.trim();
          if (!name) return alert("Please enter a name");

          this.textContent = "Sending...";
          this.disabled = true;

          const finalSeconds = Math.floor(
            (Date.now() - gameState.startTime - gameState.totalPausedTime) /
              1000
          );

          try {
            await fetch(APPS_SCRIPT_URL, {
              method: "POST",
              mode: "no-cors",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                playerName: name,
                clicks: gameState.clicks,
                time: finalSeconds,
                route: `${gameState.startPage} -> ${gameState.targetPage}`,
                timestamp: Date.now(),
              }),
            });

            this.textContent = "Saved!";
            setTimeout(() => {
              // Refresh leaderboard after submit
              fetchGlobalLeaderboard().then(() => {
                els.winModal.style.display = "none";
                els.menu.classList.remove("hidden");
                els.game.classList.add("hidden");
              });
            }, 1000);
          } catch (e) {
            alert("Error saving score (Network)");
            this.disabled = false;
          }
        });

      // Tab Switching
      document.querySelectorAll(".lb-tab").forEach((tab) => {
        tab.addEventListener("click", () => {
          document
            .querySelectorAll(".lb-tab")
            .forEach((t) => t.classList.remove("active"));
          tab.classList.add("active");
          currentLeaderboardSort = tab.dataset.sort;
          renderLeaderboard(); // Pure client-side re-render
        });
      });

      // Initialize
      renderLocalStats();
      fetchGlobalLeaderboard();
    </script>
  </body>
</html>
